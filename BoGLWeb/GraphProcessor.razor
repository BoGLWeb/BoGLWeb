@inject HttpClient Http;
@page "/graphtest"
@using GraphSynth.Representation
@using System.Xml.Serialization
@using System.Xml.Linq


<h3>Component</h3>
<PageTitle>TestApp</PageTitle>
<h1>Hello</h1>

<button @onclick="loadRuleSets">Load Rules</button>

@code {
    Dictionary<string, ruleSet> ruleSetMap = new Dictionary<string, ruleSet>();
    private List<designGraph> optiGraphs = new List<designGraph>();
    private List<designGraph> finalresult = new List<designGraph>();
    private List<int> indiceswithoutINVD = new List<int>();
    private List<int> maxIntegralCausality = new List<int>();
    private HashSet<string> nodeLabelSorted = new HashSet<string>();
    private HashSet<int> sortedIndices = new HashSet<int>();
    private int index1 = 0;
    private bool causality = false;

    public async void loadRuleSets()
    {
        List<string> ruleSetPaths = new List<string>();
        HttpClient client = new HttpClient();
        //Load Rule Location List
        HttpResponseMessage responseRuleSetList = await client.GetAsync("http://localhost:5006/Rules/RuleSetPaths.txt");
        string ruleSetListFileContent = await responseRuleSetList.Content.ReadAsStringAsync();
        using (StringReader sr = new StringReader(ruleSetListFileContent))
        {
            string? line = null;
            while ((line = sr.ReadLine()) != null)
            {
                Console.WriteLine("Loaded Rule");
                Console.WriteLine(line);
                ruleSetPaths.Add(line);
            }
        }

        int numLoaded = 0;
        var ruleDeserializer = new XmlSerializer(typeof(ruleSet));
        foreach (string str in ruleSetPaths)
        {
            HttpResponseMessage ruleSetResponse = await client.GetAsync("http://localhost:5006" + str);
            var ruleSetFileContent = await ruleSetResponse.Content.ReadAsStreamAsync();
            ruleSetMap.Add(str.Substring(6), (ruleSet)ruleDeserializer.Deserialize(ruleSetFileContent));
            var numRules = ruleSetMap[str.Substring(6)].ruleFileNames.Count;
            string ruleDir = ruleSetMap[str.Substring(6)].rulesDir;
            List<String> ruleFileNames = ruleSetMap[str.Substring(6)].ruleFileNames;

            var progStart = 5;
            var progStep = (double)(100 - progStart) / ruleFileNames.Count;
            var rules = new List<grammarRule>();
            numLoaded = 0;
            while (numLoaded < ruleFileNames.Count)
            {
                var rulePath = "/Rules/" + ruleFileNames[numLoaded];

                HttpResponseMessage ruleResponse = await client.GetAsync("http://localhost:5006/" + rulePath);
                string ruleText = await ruleResponse.Content.ReadAsStringAsync();

                var xeRule = XElement.Parse(ruleText);
                var temp = xeRule.Element("{ignorableUri}" + "grammarRule");
                var openRule = new grammarRule();
                if (temp != null)
                {
                    openRule = DeSerializeRuleFromXML(RemoveXAMLns(RemoveIgnorablePrefix(temp.ToString())));
                }

                removeNullWhiteSpaceEmptyLabels(openRule.L);
                removeNullWhiteSpaceEmptyLabels(openRule.R);

                object ruleObj = new object[] { openRule, rulePath };
                if (ruleObj is grammarRule)
                {
                    rules.Add((grammarRule)ruleObj);
                }
                else if (ruleObj is object[])
                {
                    foreach (object o in (object[])ruleObj)
                    {
                        if (o is grammarRule)
                        {
                            rules.Add((grammarRule)o);
                        }
                    }
                }
                numLoaded++;
            }

            ruleSetMap[str.Substring(6)].rules = rules;
        }
    }

    private grammarRule DeSerializeRuleFromXML(string xmlString)
    {
        var stringReader = new StringReader(xmlString);
        var ruleDeserializer = new XmlSerializer(typeof(grammarRule));
        var newGrammarRule = (grammarRule)ruleDeserializer.Deserialize(stringReader);
        if (newGrammarRule.L == null)
        {
            newGrammarRule.L = new designGraph();
        }
        else
        {
            newGrammarRule.L.internallyConnectGraph();
        }

        if (newGrammarRule.R == null)
        {
            newGrammarRule.R = new designGraph();
        }
        else
        {
            newGrammarRule.R.internallyConnectGraph();
        }

        return newGrammarRule;
    }

    private string RemoveXAMLns(string str)
    {
        return str.Replace("xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presenation\"", "");
    }

    private string RemoveIgnorablePrefix(string str)
    {
        return str.Replace("GraphSynth:", "").Replace("xmlns=\"ignorableUri\"", "");
    }

    private void removeNullWhiteSpaceEmptyLabels(designGraph g)
    {
        g.globalLabels.RemoveAll(string.IsNullOrWhiteSpace);
        foreach (var a in g.arcs)
        {
            a.localLabels.RemoveAll(string.IsNullOrWhiteSpace);
        }
        foreach (var a in g.nodes)
        {
            a.localLabels.RemoveAll(string.IsNullOrWhiteSpace);
        }
        foreach (var a in g.hyperarcs)
        {
            a.localLabels.RemoveAll(string.IsNullOrWhiteSpace);
        }
    }

    public async void loadExampleSystemDiagram()
    {

    }

    private designGraph systemGraph = null;
    private designGraph unSimplifiedGraph = null;
    private designGraph simplifiedGraphWithDir = null;
    private designGraph systemGraphUser = null;

    private List<option> options = new List<option>();

    public void obtainCausality()
    {
        //TODO Rename variables
        Stack<designGraph> sysGraphs = new Stack<designGraph>();
        sysGraphs.Push(systemGraph.copy());
        var sys = sysGraphs.Pop();
        options = ruleSetMap["NewCausalityMethodRuleset"].recognize(sys, false, null);

        while (options.Count > 0)
        {
            options[0].apply(sys, null);
            options = ruleSetMap["NewCausalityMethodRuleset"].recognize(sys, false, null);
        }

        sysGraphs.Push(sys);
        while (sysGraphs.Count > 0)
        {
            sys = sysGraphs.Pop();
            options = ruleSetMap["NewCausalityMethodRuleset_2"].recognize(sys, false, null);
            if (options.Count > 0)
            {
                foreach (var opt in options)
                {
                    var gra = sys.copy();
                    GraphSynth.Search.SearchProcess.transferLmappingToChild(gra, sys, opt.nodes, opt.arcs, opt.hyperarcs);
                    opt.apply(gra, null);
                    sysGraphs.Push(gra);
                }
            }
            else
            {
                sysGraphs.Push(sys); //This was .Add() in the desktop version which doesn't exist and I cant find documentation on, so this element may be getting added to the wrong location
            }

            foreach (var item in sysGraphs)
            {
                sys = item.copy();
                options = ruleSetMap["NewCausalityMethodRuleset_3"].recognize(sys, false, null);

                while (options.Count > 0)
                {
                    options[0].apply(sys, null);
                    options = ruleSetMap["NewCausalityMethodRuleset_3"].recognize(sys, false, null);
                }
                sysGraphs.Push(sys);
            }

            sysGraphs.Clear();
        }

        //line 1330
        while (sysGraphs.Count > 0)
        {
            sys = sysGraphs.Pop();
            options = ruleSetMap["INVDMarkerRules"].recognize(sys, false, null);
            while (options.Count > 0)
            {
                options[0].apply(sys, null);
                options = ruleSetMap["INVDMarkerRules"].recognize(sys, false, null);
            }

            Stack<designGraph> graphss = new Stack<designGraph>(); //graphss in desktop verison
            List<designGraph> graph_SSS = new List<designGraph>(); //graph_SSS in desktop version
            graphss.Push(sys);

            //There is a random open curly brace here, no idea why, didn't put it here, if thinks break maybe thats the problem? who knows
            //The curly brackets can be used to for scope, interesting. I didn't put them here and just redefined options1 instead
            var stackHead = graphss.Pop(); //graphS in desktop version
            var options1 = ruleSetMap["CalibrationNewRuleset"].recognize(stackHead, false, null);

            if (options1.Count > 0)
            {
                foreach (var opt in options1)
                {
                    var stackHeadCopy = stackHead.copy();
                    GraphSynth.Search.SearchProcess.transferLmappingToChild(stackHeadCopy, stackHead, opt.nodes, opt.arcs, opt.hyperarcs);
                    opt.apply(stackHeadCopy, null);
                    graph_SSS.Add(stackHeadCopy);
                }
            }
            else
            {
                graph_SSS.Add(stackHead);
            }

            foreach (var opt in graph_SSS)
            {
                options1 = ruleSetMap["CalibrationNewRuleset"].recognize(opt, false, null);

                while (options1.Count > 0)
                {
                    options1[0].apply(opt, null);
                    options1 = ruleSetMap["CalibrationNewRuleset"].recognize(opt, false, null);
                }

                graphss.Push(opt);
            }

            graph_SSS.Clear();

            while (graphss.Count > 0)
            {
                var graphS = graphss.Pop();
                options1 = ruleSetMap["RFlagCleanRuleset"].recognize(graphS, false, null);
                while (options1.Count > 0)
                {
                    options1[0].apply(graphS, null);
                    options1 = ruleSetMap["RFlagCleanRuleset"].recognize(graphS, false, null);
                }
                graph_SSS.Add(graphS);
            }

            foreach (var opt in graph_SSS)
            {
                graphss.Push(opt);
            }

            graph_SSS.Clear();

            //Line 1411
            while (graphss.Count > 0)
            {
                var graphS = graphss.Pop();
                options1 = ruleSetMap["ICFixToolRuleset"].recognize(graphS, false, null);

                //There was stuff commented out here, ignoring it for now

                while (options1.Count > 0)
                {
                    options1[0].apply(graphS, null);
                    options1 = ruleSetMap["ICFixTotalRuleset"].recognize(graphS, false, null);
                }

                graph_SSS.Add(graphS);
            }

            foreach (var op in graph_SSS)
            {
                options = ruleSetMap["TransformerFlipRuleset"].recognize(op, false, null);

                if (options.Count > 0)
                {
                    options[0].apply(op, null);
                    sysGraphs.Push(op);
                }
                else
                {
                    options = ruleSetMap["TransformerFlipRuleset2"].recognize(op, false, null);

                    if (options.Count > 0)
                    {
                        options[0].apply(op, null);
                        sysGraphs.Push(op);
                    }
                    else
                    {
                        optiGraphs.Add(op); //TODO This doesn't exists yet, make it
                    }
                }
            }

        }

        //Line 1473
        foreach (var opt in optiGraphs)
        {
            options = ruleSetMap["Clean23Ruleset"].recognize(opt, false, null);

            while (options.Count > 0)
            {
                options[0].apply(opt, null);
                options = ruleSetMap["Clean23Ruleset"].recognize(opt, false, null);
            }

            finalresult.Add(opt); //TODO This doesn't exist yet, make it
        }

        indiceswithoutINVD.Clear(); //TODO This doesn't exist yet, make it
        maxIntegralCausality.Clear(); //TODO This doesn't exist yet, make it

        for (int ii = 0; ii < finalresult.Count; ii++)
        {
            bool index = checkINVD(finalresult[ii]); //TODO This doesn't exist yet, make it

            if (index == false)
            {
                indiceswithoutINVD.Add(ii);
                maxIntegralCausality.Add(checkICs(finalresult[ii])); //TODO This doesn't exist yet, make it
            }
        }

        if (indiceswithoutINVD.Count == 0)
        {
            //We have an error
            //TODO Create a better way to show this error message
            Console.WriteLine("THERE IS AN ISSUE!!!!!");
        }
        else
        {
            int currentHashSetcount = 0;
            int nn = 0;
            foreach (var n in indiceswithoutINVD)
            {
                //Line 1523
                List<string> nodeLabelsCau = new List<string>();
                var cauGraph = finalresult[n];

                foreach (var arcC in cauGraph.arcs)
                {
                    if (arcC.localLabels.Contains("I2") && arcC.localLabels.Contains("SAME"))
                    {
                        for (int iii = 0; iii < arcC.To.localLabels.Count; iii++)
                        {
                            if (arcC.To.localLabels[iii].Contains("iadded"))
                            {
                                nodeLabelsCau.Add(arcC.To.localLabels[iii]);

                            }

                        }
                    }
                    if (arcC.localLabels.Contains("C3") && arcC.localLabels.Contains("OPP"))
                    {
                        for (int iii = 0; iii < arcC.From.localLabels.Count; iii++)
                        {
                            if (arcC.From.localLabels[iii].Contains("cadded"))
                            {
                                nodeLabelsCau.Add(arcC.From.localLabels[iii]);

                            }

                        }
                    }

                }

                if (nodeLabelsCau.Count > 0)
                {
                    nodeLabelsCau.Sort();

                    string combined = "";
                    foreach (var x in nodeLabelsCau)
                        combined += x;

                    nodeLabelSorted.Add(combined);

                    //need to add index numbers as well into a list

                    if ((nn + 1) == nodeLabelSorted.Count) //for the first one, it will be same
                    {
                        sortedIndices.Add(n);
                        currentHashSetcount++;
                    }

                    if (currentHashSetcount <= nodeLabelSorted.Count)
                    {
                        sortedIndices.Add(n);
                        currentHashSetcount++;
                    }

                }
                nn++;
            }
            // nodeNames_Cau.Sort();
            // nodeNames.Add(nodeNames_Cau);

            List<int> maxIntegralCaus = new List<int>();

            foreach (var n in sortedIndices)
            {
                //use the indiceswithoutINVD to obtain the index in that list

                var indexindex = indiceswithoutINVD.FindIndex(item => item == n);
                maxIntegralCaus.Add(maxIntegralCausality[indexindex]);

            }

            index1 = maxIntegralCausality.IndexOf(maxIntegralCausality.Max());

            //  foreach (var no in finalresult[index1].nodes)

            //now add to the combo-box

            for (int pp = 0; pp < nodeLabelSorted.Count; pp++)
            {
                var stringtobeadded = "Option " + (pp + 1).ToString();

                //Graph_BG3.CausalOptions.Items.Add(stringtobeadded);
            }

            //Graph_BG3.CausalOptions.IsEnabled = true;


            //rectangles_BG_Causality.Clear();
            //lines_BG_Causality.Clear();
            //connections_BG_Causality.Clear();
            causality = true;
        }

        //Graph_BG3.CausalOptions.SelectedIndex = 0;
        //causaloptions_selection();

    }

    private int checkICs(designGraph designGraph)
    {
        int xx = 0;
        foreach (arc a in designGraph.arcs)
        {
            if (a.localLabels.Contains("I2") && a.localLabels.Contains("SAME"))
                xx = xx + 1;
            if (a.localLabels.Contains("C3") && a.localLabels.Contains("OPP"))
                xx = xx + 1;
        }

        return (xx);

    }

    private bool checkINVD(designGraph designGraph)
    {
        foreach (node n in designGraph.nodes)
        {
            foreach (string x in n.localLabels)
            {
                if (x.Contains("INVD"))
                    return true;
                if (x.Contains("Flipped"))
                    return true;
            }

        }
        return false;
    }

}

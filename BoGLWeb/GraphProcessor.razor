@inject HttpClient Http;
@page "/graphtest"
@using GraphSynth.Representation
@using System.Xml.Serialization
@using System.Xml.Linq


<h3>Component</h3>
<PageTitle>TestApp</PageTitle>
<h1>Hello</h1>

<button @onclick="loadRuleSets">Load Rules</button>

@code {
    public ruleSet systemToBondGraph = null;
    public ruleSet directionRuleSet = null;
    public ruleSet directionRuleSet2 = null;
    public ruleSet directionRuleSet3 = null;
    public ruleSet simplificationRuleset = null;
    public ruleSet simplificationRuleset2 = null;
    public ruleSet newCausalityMethodRuleset = null;
    public ruleSet newCausalityMethodRuleset_2 = null;
    public ruleSet newCausalityMethodRuleset_3 = null;
    public ruleSet iNVDMarkerRules = null;
    public ruleSet iNVDMarkerRules_2 = null;
    public ruleSet calibrationNewRuleset = null;
    public ruleSet calibrationNewRuleset_2 = null;
    public ruleSet rFlagCleanRuleset = null;
    public ruleSet iCFixTotalRuleset = null;
    public ruleSet transformerFlipRuleset = null;
    public ruleSet transformerFlipRuleset2 = null;
    public ruleSet clean23Ruleset = null;

    public ruleSet solidworksRuleset = null;

    public ruleSet state_Ruleset_1 = null;
    public ruleSet state_Ruleset_2 = null;
    public ruleSet state_Ruleset_3 = null;
    public ruleSet state_FormatGraph = null;
    public ruleSet state_Sum_Remove = null;
    public ruleSet state_FormatForSum = null;
    public ruleSet state_Sum_AddLabels = null;


    public async void loadRuleSets() {
        List<string> ruleSetPaths = new List<string>();
        HttpClient client = new HttpClient();
        //Load Rule Location List
        HttpResponseMessage responseRuleSetList = await client.GetAsync("http://localhost:5006/Rules/RuleSetPaths.txt");
        string ruleSetListFileContent = await responseRuleSetList.Content.ReadAsStringAsync();
        using (StringReader sr = new StringReader(ruleSetListFileContent)) {
            string? line = null;
            while ((line = sr.ReadLine()) != null) {
                Console.WriteLine("Loaded Rule");
                Console.WriteLine(line);
                ruleSetPaths.Add(line);
            }
        }

        int numLoaded = 0;
        var ruleDeserializer = new XmlSerializer(typeof(ruleSet));
        foreach (string str in ruleSetPaths) {
            HttpResponseMessage ruleSetResponse = await client.GetAsync("http://localhost:5006" + str);
            var ruleSetFileContent = await ruleSetResponse.Content.ReadAsStreamAsync();
            systemToBondGraph = (ruleSet)ruleDeserializer.Deserialize(ruleSetFileContent);
            //TODO make this use multiple grammar rules
            var numRules = systemToBondGraph.ruleFileNames.Count;
            string ruleDir = systemToBondGraph.rulesDir;
            List<String> ruleFileNames = systemToBondGraph.ruleFileNames;

            var progStart = 5;
            var progStep = (double)(100 - progStart) / ruleFileNames.Count;
            var rules = new List<grammarRule>();
            numLoaded = 0;
            while (numLoaded < ruleFileNames.Count) {
                var rulePath = "/Rules/" + ruleFileNames[numLoaded];

                HttpResponseMessage ruleResponse = await client.GetAsync("http://localhost:5006/" + rulePath);
                string ruleText = await ruleResponse.Content.ReadAsStringAsync();

                var xeRule = XElement.Parse(ruleText);
                var temp = xeRule.Element("{ignorableUri}" + "grammarRule");
                var openRule = new grammarRule();
                if (temp != null){
                    openRule = DeSerializeRuleFromXML(RemoveXAMLns(RemoveIgnorablePrefix(temp.ToString())));
                }

                removeNullWhiteSpaceEmptyLabels(openRule.L);
                removeNullWhiteSpaceEmptyLabels(openRule.R);

                object ruleObj = new object[] {openRule, rulePath}; 
                if (ruleObj is grammarRule) {
                    rules.Add((grammarRule)ruleObj);
                } else if (ruleObj is object[]) {
                    foreach (object o in (object[]) ruleObj){
                        if (o is grammarRule) {
                            rules.Add((grammarRule)o);
                        }
                    }
                }
                numLoaded++;
            }

            systemToBondGraph.rules = rules;
        }
    }

    private grammarRule DeSerializeRuleFromXML(string xmlString) {
        var stringReader = new StringReader(xmlString);
        var ruleDeserializer = new XmlSerializer(typeof(grammarRule));
        var newGrammarRule = (grammarRule)ruleDeserializer.Deserialize(stringReader);
        if (newGrammarRule.L == null) {
            newGrammarRule.L = new designGraph();
        } else {
            newGrammarRule.L.internallyConnectGraph();
        }

        if (newGrammarRule.R == null) {
            newGrammarRule.R = new designGraph();
        } else {
            newGrammarRule.R.internallyConnectGraph();
        }

        return newGrammarRule;
    }

    private string RemoveXAMLns(string str) {
        return str.Replace("xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presenation\"", "");
    }

    private string RemoveIgnorablePrefix(string str) {
        return str.Replace("GraphSynth:", "").Replace("xmlns=\"ignorableUri\"", "");
    }

    private void removeNullWhiteSpaceEmptyLabels(designGraph g) {
        g.globalLabels.RemoveAll(string.IsNullOrWhiteSpace);
        foreach (var a in g.arcs) {
            a.localLabels.RemoveAll(string.IsNullOrWhiteSpace);
        }
        foreach (var a in g.nodes) {
            a.localLabels.RemoveAll(string.IsNullOrWhiteSpace);
        }
        foreach (var a in g.hyperarcs) {
            a.localLabels.RemoveAll(string.IsNullOrWhiteSpace);
        }
    }

}
